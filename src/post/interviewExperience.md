# 面经

## 常见问题

### 项目拷打

* 遇见的问题,项目的亮点和难点
* 功能拷打
* **地下城探险**：1.使用可靠的UDP（TCP中有粘包特性会形成延迟，UDP可无延迟发送） 

***



## C++

***

### 深拷贝与浅拷贝

* **浅拷贝**是只复制对象的值，而不进行资源的复制，共享一块内存，容易造成一个对象修改值后另一个值也改变；一个对象删除后另一个对象的指针成野指针
* **深拷贝**是同时进行资源的复制，开辟一块新的内存，互不影响



### 多态的实现

* 编译时多态：**函数重载**，**运算符重载**
* 运行时多态：**虚函数**

### 虚函数

* 虚函数主要由虚函数指针与虚函数表构成
* **虚函数表**：一般被分配在只读数据段中

### 内存分配

* **栈区**：主要存储函数参数，局部变量，函数结束后自动销毁
* **堆区**：动态分配内存区（手动分配内存），用malloc和free等来进行管理
* **静态区**：存储静态变量与全局变量，初始化的变量存于数据段，未初始的存于bss段中；程序启动分配，结束释放
* **常量区**：const关键字定义的常量
* **代码区**：编译后的代码（只读）

### 智能指针

* 智能指针主要是解决内存泄露，野指针，悬空指针问题
* [C/C++面试：什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？_什么是智能指针?智能指针有什么作用?分为哪几种?各自有什么样的特点?-CSDN博客](https://blog.csdn.net/zhizhengguan/article/details/112302192)

### C++关键字

* **extern**：当与C+func连用时告诉编译器应当按照C的规则去翻译



## C#

***

### C#底层原理

#### **mono和IL2CPP**

* **mono**： 由编译器编译为**IL**（中间语言），再通过**JIT**（即时编译）编译为机器码。**优点**：无需额外编译，开发和测试效率高。支持运行时动态加载和执行动态生成的代码。跨平台支持。**缺点**：JIT编译在运行时进行，性能不如预编译的机器代码。IL易于反编译，安全性低。
* **IL2CPP**：是unity自研的工具链，先将C#编译成IL，再将IL代码转成C++代码，最后编译成机器代码。**优点**：高性能。安全性高。跨平台支持，一致性。**缺点**：编译耗时，无法动态支持。

### **结构体与类**

* class是引用类型，struct是值类型；class能给字段赋初始值；创建新对象的方式不同
* 类适用于**数据持久化**，特别是需要频繁改动，因为是引用类型，所以传递的是指针（一般用于复杂的游戏对象，组件系统，场景管理）
* struct一般用于**轻量化的数据**，不经常改动（比如物理，数学）

### **引用类型与值类型**

* 变量存储是直接存储的数据。
* 引用类型持有的是数据的引用。（例如：当声明一个class时，先在栈上开辟一块内存用于存储地址，当实例化此类时才在堆上分配空间并将地址给栈空间。）

### **拆箱与装箱**

* 拆箱：将引用类型转化为值类型，将堆上的值拷贝到栈上
* 装箱：将值类型转化为引用类型，，在堆上分配内存，并将栈上的值拷贝到堆上（更消耗，因为涉及到堆内存的分配）
* **避免boxing与unboxing**：使用泛型避免装箱；避免频繁使用ToString避免频繁装箱；

### 委托与事件

* **委托**像是一类函数（返回值类型与参数列表都一致）的链表 同时委托也是一种类型。（delegate）
* **事件**是一种特殊的委托，对**委托**再一次封装，禁用=，更加安全。只有定义他的类才可调用。（event）

### 字典（Dictionary）

* 字典底层基于HashTable实现，大多数情况下查找，插入和删除时间复杂度都为O(1)；
* **哈希函数** 当向字典添加一个键值对时，字典使用哈希函数计算出一个哈希值，**哈希值**决定了键值对在底层数组的存储位置
* **哈希函数** 通常调用GetHashCode()函数 ，方法返回一个整数值
* 哈希表的结构：**数组** 字典的底层是一个数组（俗称“桶”），每个桶存储一个链表来处理哈希冲突，**链表** 当两个键值对映射到同一个桶里面，就使用链表存储
* 哈希冲突过多导致：1，性能下降，查找和删除的复杂度可能会降成O(1)

### 集合（List）

* List底层是由动态数组实现，具有自动调整大小的能力
* **扩容**通常是将数组大小翻倍，这样可以减少频繁扩容，提高性能。
* **扩容**方式：创建一个更大的数组，，将旧数组中的元素放在新数组中，将新数组的引用赋给内部存储的数组。
* List并**不是线程安全**的，因此在多线程情况下需要注意线程安全，可通过锁机制或者其他线程同步技术来确保线程安全。

### 无序数组如何优化增删效率

* 采用**尾部操作**优化效率，在尾部添加元素，将要删除的元素与尾部交换位置
* 使用**哈希表**或**链表**进行优化

### 垃圾回收

* **GC**:只回收堆中内存（栈中内存自动释放），gc是通过代的机制实现[[C#【必备技能篇】垃圾回收机制(GC)的理解（资源清理+内存管理）_c# gc-CSDN博客](https://blog.csdn.net/sinat_40003796/article/details/128041837)]

### 四叉树搜索

### 八叉树搜索

***

## 数据结构

***

### 排序算法

#### 插入排序

时间复杂度：O(N^2)；空间复杂度：O(1)；稳定

```C++
void InsertSort(int *a,int n){
    for(int i=0;i<n-1;i++){
		int x=a[i+1];
        int end=i;
        while(end>=0){
            if(a[end]>x){
                a[end+1]=a[end];
                end--;
            }
            else break;
        }
        a[end+1]=x;
    }
}
```

#### 希尔排序

时间复杂度：不稳定，根据gap取值进行改变；空间复杂度：O(1)；不稳定

```C++
void ShellSort(int *a,int n){
    int gap=n;
    while(gap>1){
        gap=gap/3+1;
        for(int i=0;i<n-gap;i++){
            int end=i;
            int x=a[end+gap];
            while(end>=0){
                if(a[end]>x){
                    a[end+gap]=a[end];
                    end-=gap;
                }
                else break;
            }
            a[end+gap]=x;
        }
    }

}
```

#### 快速排序

时间复杂度：不稳定，好的情况O(logn*n)；空间复杂度：O(1)；不稳定

```C++
void QuickSort(int arry[],int low,int high)
{
    int t=low;
    int i=low,j=high;
    while(i<j){
    while(arry[i]<=arry[t]&&i<j)
        i++;
    while(arry[j]>=arry[t]&&i<j)
        j--;
    if(i<j)swap(arry[i],arry[j]);
    }
    swap(arry[i],arry[t]);
    QuickSort(arry,i+1,high);
    QuickSort(arry,low,i-1);
}
```

#### 堆排序

不稳定排序，空间复杂度稳定在O(1),时间复杂度平均O(nlogn)，最坏也是O(nlogn)

```C++
void HeapAdjust(int start,int end) 
{
	int tmp = arr[start];
	for(int i=2*start+1;i<=end;i=2*i+1){
		if(i<end&&arr[i]<arr[i+1]){
			i++;
		}
		if(arr[i]>tmp){
			arr[start] = arr[i];
			start = i;
		}else{
			break;
		}
	}
	arr[start] = tmp;
}

void HeapSort(int len)
{
	for (int i = len / 2 - 1; i >= 0; i--) {
		HeapAdjust(i, len - 1);
	}
	int tmp;
	for(int i=0;i<len-1;i++){
		tmp = arr[0];
		arr[0] = arr[len-1-i];
		arr[len-1-i] = tmp;
		HeapAdjust(0,len-1-i-1);
	}
}
```



### 搜索算法

#### 二分

局限性大，只能适用于有序数组

#### 二叉树



## unity

***

### 游戏开发

* Monobehaviour的生命流程：Awake，OnEnable，Start，Update，FixedUpdate，LateUpdate，OnDiabale，OnDestroy
* **协程**：是一种轻量级的用户空间线程，被广泛用于异步，延迟操作，分帧处理；协程是基于IEnumerator和C#的关键字yield实现，yeild将代码分成几段放入IE容器中依次执行。

### UGUI

* **UIGUI的渲染流程**:1.canvas构建(将顶点数据，UV，颜色等生成对应的顶点数据。2.批处理:将所有数据提交道canvsRander进行批处理（动态合批，静态合批，合图）。3.渲染提交(DrawCall)。
* **优化性能**:合批处理，动静分离

#### 网络开发

* **GDC中的SpaceTime**：将数据库与服务端相嵌合
* 网络同步策略：**帧同步**：适合网络波动较大，及时要求高的游戏。**状态同步**：服务器权威最高，反作弊能力强，对网络要求高。
* **帧同步**：  1.需要准确的物理和数学运算库（浮点数有误差（解决方案：取整，容许小概率误差，逻辑编写分离））。2.  断线重连（进行追帧）。
* **断线重连**:1.定期发送心跳包检测来连接状态，如果发送心跳包失败就进行断线重连；设置重连计数器，如果超过限制次数就放弃重连；成功则处理队列中未完成的请求
* **断线重连**:2.使用websocket协议:双向连接(1.持久化链接，保证数据的实时性，减少网络负载减少http请求(用以传输html等的应用层协议，同时可用于可靠的传输层)。2.服务器可主动向客户端发送信息无需客户端请求)。**生命周期:**1.链接建立时，客户端发送握手请求，服务端发送握手响应。2.链接断开时，由客户端或服务端发送关闭帧，在下一帧链接断开。

### 优化

#### 滥用update影响性能

* update会在所有激活的monobehaviour中被调用，造成性能损失
* 解决方法：**合并update**，**事件驱动**，**协程**，**按需激活**，**对象池**

#### 联机同步

* 保持游戏的平稳性和流畅性的常见方法是建立**缓存区**，将数据包存入队列中，客户端每次tick都执行处理一个数据包，这是一个**增加延迟，减少抖动**的方法。
* **客户端预测**：
* **帧锁定**：

### 渲染

* **剔除裁剪步骤**:**CPU剔除**:1.层级剔除，根据是否active，layer是否显示。2.视锥剔除，进行矩形和平面的相交测试。3.LOD剔除，通过LODGroup组件根据距离相机切换不同模型或者直接隐藏。**CPU->GPU交接阶段**：1.视口裁剪，GPU在光栅化阶段剔除viewport外的像素。2.深度裁剪，比较深度缓冲的值如被遮挡则丢弃。

### ECS框架

* ECS是一种数据导向的架构模式，以传统面向对象的unity开发不同的是数据与逻辑完全分离
* ECS的优点是1.相似的组件存储在连续的内存块中而不是分散在堆中，提高内存内存命中率。2.避免虚函数调用链的开销，直接调用函数而不是自动调用。3.减少垃圾回收，用结构体代替类，减少gc。
* ECS实现事件和通信的方法：
* ECS实现对象间的交互：

### 热更新

* **HybridCLR热更新**：

## Lua

### lua实现面向对象特性

* 通过lua的元表以及_index索引特性实现
* 

## 设计模式

***

### 单例模式

* 懒汉模式：线程不安全，需要加锁
* 饿汉式：线程安全，main函数开始时就创建

### 工厂模式

* 

## 操作系统

***

### 死锁与银行家算法



## 计算机网络

***

### OSI模型七层模型

* 物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

### TCP/IP协议

* TCP与UDP区别：TCP传输模式是流传输，UDP传输是数据报连接；TCP是

* **三次握手与四次挥手**：1.客户端发送SYN报文段，请求建立连接随机生成一个序列号。2.服务端收到SYN数据段，回复SYN-ACK数据段确认序列号并发送自己的序列号。3.客户端收到SYN-ACK后，发送ACK报文段，确认序列号建立连接。1.客户端发送FIN报文段表示要断开连接。2.服务端收到FIN确认断开连接，发送ACK。3.服务端发送FIN报文段表示断开连接。4.客户端收到FIN发送ACK断开连接。
* **粘包和半包**：是因为网络带宽限制，大数据包在传输过程中被分成多段或多个数据包被看作一个数据包，常见的解决方案是为数据包添加包头清晰定义信息边界。
* **滑动窗口**：是TCP实现发送方和接受方之间的流量控制和可靠性传输的机制，发送方不需要等待每个数据段的确认从而提高传输效率。

##  计算机组成原理

***

# **图形学**

***

### 渲染方式

* **PBR**:基于物理的渲染方式

### 渲染过程

**应用程序阶段**

* 进行视锥剔除，查询可能绘制的图像并渲染数据，设置渲染状态和绑定shader，调用drawcall

**几何阶段**

* 顶点处理阶段
* 裁剪阶段

**光栅化阶段**

**像素处理阶段**

#### 渲染优化

* drawcall（CPU调用GPU进行绘制），过多的drawcall会导致性能下降，进行批处理减少drawcall可以有效解决（通常是将多个材质合并为一个材质）

* 过度绘制会导致overdraw（多次绘制同一像素）



